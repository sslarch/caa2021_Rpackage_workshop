---
title: "R functions"
author: "Clemens Schmid"
output: 
  beamer_presentation:
    slide_level: 2
    theme: "Singapore"
    includes:
      in_header: preamble.tex
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

# Functions

## What is a function?

# Functions in R

R provides a several thousand functions in the core packages (base, graphics, stats, methods, ...)

```r
base::mean(c(1,2,3))
```

More functions are distributed through packages in a large ecosystem (CRAN, Github, ...)

```r
c14bazAAR::get_c14data("IRDD")
```

Developers and user can easily define own functions

```r
# function definition
myfunc <- function(x, y) {
  x + y
}
# function application
myfunc(1,2)
```

## Implementation

## Syntax

R uses the following syntax for function definition

```r
myfunc <- function(x, y) {
  z <- x + y
  return(z)
}
```
- Function name: `myfunc`
- Arguments: `x` and `x`
- Function body:

```r
z <- x + y
return(z)
```

- Return value: `return(z)`

## Syntax

We can reduce this: 

Functions don't need an explicit return statement. The value of the last statement is returned

```r
myfunc <- function(x, y) { x + y }
```

## Syntax

Functions also do not need a name: Lambda functions

```r
function(x, y) { x + y }
```

This is useful when we want to use a function only once for a very specific purpose (later: Higher Order functions)

```r
myvec1 <- c(1,2,3)
myvec2 <- c(5,6,7)
Map(
  f = function(x, y) { x + y },
  myvec, myvec2
)
```

## Syntax

R 4.1 introduced even shorter syntax for function definition

```r
\(x, y) x + y
```

This makes for really elegant code

```r
myvec1 <- c(1,2,3)
myvec2 <- c(5,6,7)
Map(
  f = \(x, y) x + y,
  myvec1, myvec2
)
```

But this syntax is very new and only works for the latest R versions

## Input and Output

Each function has zero, one or multiple input arguments, but only exactly one output argument

Even a function without output returns `NULL`

```r
myfunc <- function(x, y) { cat(x) }
```

Usually the output of functions is immediatelly printed on the console. This can be prevented with `invisible` instead of `return`

```r
myfunc <- function(x, y) {
  z <- x + y
  invisible(z)
}
```

## Types

Every object in a programming environment has some type. R function have no way to being explicit about this: Dynamic type system

```r
myfunc <- function(x, y) { x + y }
```

We can use myfunc with every input the `+` operator is defined, so all kinds of numeric data types

```r
class(1.1) # "numeric"
myfunc(1.1, 2.4) # 3.5
```

```r
class(1L) # "integer"
myfunc(1L, 2L) # 3
```

```r
class(1i) # "complex"
myfunc(1i, 2i) # 0+3i
```

## Types

But it fails for other datatypes

```r
class("A") # "character"
myfunc("A", "B") 
# Error in x + y : 
# non-numeric argument to binary operator
```

Advantages of dynamic typing

- less verbose function definition
- very flexible functions (functions often automatically work for multiple input types)

Disadvantages

- Nasty error messages: No explicit input validation
- No type validation at "compile"-time

## Namespaces

Functions we did not define ourself always exist in some package

- For core R functions we can just access them

```r
mean()
```

- For all other packages we have to load the respective namespace to access their functions

```r
library(ggplot2)
require(magrittr) # rarely used
```

- Or we contextualize the function explictly

```r
dplyr::mutate()
c14bazAAR:::check_connection_to_url() # internal
```

## Namespaces

When developing a package, this becomes less convenient:

All functions need to be explicitly called, except they come from base R

```r
stats::anova()
```

Alternatively we could use the `importFrom` statement in the `NAMESPACE` file

# Advanced topics

## Default input values

R functions can have default values for all of their arguments. That is a great way to simplify complicated interfaces for normal usecases

```r
myfunc <- function(x, y = 5) {
  z <- x + y
  return(z)
}
```

```r
myfunc(1) # 6
myfunc(1, 2) # 3
```

Default arguments can even be used in the definition of other default arguments

```r
calibrate <- function (
  x, choices = c("calrange"), sigma = 2, 
  calCurves = rep("intcal20", nrow(x))
) { ... }
```

## The ellipsis

## Higher-order functions

## Environments

## Operators

## Chaining functions together

# Practical concerns

## Function length and scope

## Input argument validation

## Error handling/messages

# Exercise

- Split a prepared script into functions
